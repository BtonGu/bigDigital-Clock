#ifndef __LCD12864_H__ 
#define __LCD12864_H__ 
#define uchar unsigned char
#define uint  unsigned int


/*定义12864液晶屏数据线--------------------------------------------------------------*/
sbit LCM_RS  = P3^3;   //模式位，为0输入指令，为1输入数据 
sbit LCM_RW  = P3^4;   //读写位，为0读，为1写 
sbit LCM_EN  = P3^5;   //使能位，高脉冲   
sbit PSB     = P3^6;
sbit LED     = P3^7;
#define Lcd_Bus P1    //LCM12864数据总线，P0.0--P0.7对应连接DB0--DB7


/*液晶数字符号图片,宽度x高度=16x32---------------------------------------------------*/
//PCtoLCD2002取模:顺向,逐行式
uchar code num1632[11][64]={	

{//图片数字0
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x3E,0x78,0x3E,0x78,0x5E,0x78,0x5E,0x78,0x9E,0x78,0x9E,
0x79,0x1E,0x79,0x1E,0x7A,0x1E,0x7A,0x1E,0x7C,0x1E,0x7C,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00,},

{//图片数字1
0x00,0x00,0x00,0x38,0x00,0x78,0x00,0xF8,0x01,0xF8,0x01,0xF8,0x00,0x78,0x00,0x78,
0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,
0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,
0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x78,0x00,0x00},

{//图片数字2
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x3E,0x00,0x7E,0x00,0xFC,0x01,0xF8,
0x03,0xF0,0x07,0xE0,0x0F,0xC0,0x1F,0x80,0x3F,0x00,0x7E,0x00,0x7C,0x00,0x78,0x00,
0x78,0x00,0x78,0x00,0x78,0x1E,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x00,0x00},

{//图片数字3
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x00,0x1E,0x00,0x1E,0x00,0x3E,0x0F,0xFC,0x0F,0xF8,
0x0F,0xF8,0x0F,0xFC,0x00,0x3E,0x00,0x1E,0x00,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},

{//图片数字4
0x00,0x00,0x00,0x1C,0x00,0x3C,0x00,0x7C,0x00,0x7C,0x00,0xFC,0x01,0xFC,0x01,0xFC,
0x03,0xFC,0x07,0xBC,0x07,0xBC,0x0F,0x3C,0x0F,0x3C,0x1E,0x3C,0x1E,0x3C,0x3C,0x3C,
0x3C,0x3C,0x78,0x3C,0x78,0x3C,0x78,0x3C,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,
0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x00},
//图片数字5
0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x78,0x00,0x78,0x00,0x78,0x00,
0x78,0x00,0x78,0x00,0x7B,0xF0,0x7F,0xF8,0x7F,0xFC,0x7F,0xFE,0x7E,0x3E,0x7C,0x1E,
0x7C,0x1E,0x00,0x1E,0x00,0x1E,0x00,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00,

{//图片数字6
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x00,0x78,0x00,0x78,0x00,0x7B,0xF0,0x7F,0xF8,0x7F,0xFC,0x7F,0xFE,
0x7C,0x3E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},

{//图片数字7
0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x78,0x1E,0x00,0x1E,0x00,0x3C,
0x00,0x3C,0x00,0x78,0x00,0x78,0x00,0xF0,0x00,0xF0,0x01,0xE0,0x01,0xE0,0x03,0xC0,
0x03,0xC0,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,
0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x07,0x80,0x00,0x00},

{//图片数字8
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x3F,0xFC,0x1F,0xF8,0x1F,0xF8,
0x3F,0xFC,0x7C,0x3E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},

{//图片数字9
0x00,0x00,0x0F,0xF0,0x1F,0xF8,0x3F,0xFC,0x7F,0xFE,0x7C,0x3E,0x78,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x78,0x1E,0x7C,0x3E,
0x7F,0xFE,0x3F,0xFE,0x1F,0xFE,0x0F,0xDE,0x00,0x1E,0x00,0x1E,0x00,0x1E,0x78,0x1E,
0x78,0x1E,0x78,0x1E,0x7C,0x3E,0x7F,0xFE,0x3F,0xFC,0x1F,0xF8,0x0F,0xF0,0x00,0x00},
	
{// 图片":"	10
//6X6方点
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x07,0xE0,
0x07,0xE0,0x07,0xE0,0x07,0xE0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x07,0xE0,0x07,0xE0,0x07,0xE0,
0x07,0xE0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

};
/*16x16图标--------------------------------------------------------------------------*/
//PCtoLCD2002取模:顺向,逐行式/
uchar code bmp1616[3][32]={
//"℃"	  tt=0
{0x00,0x00,0x30,0x00,0x48,0x00,0x49,0xC0,0x33,0xE8,0x06,0x38,0x0C,0x18,0x0C,0x08,
0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x06,0x08,0x03,0x10,0x01,0xE0,0x00,0x00},     

//温度计图标
{0x00,0x00,0x01,0x80,0x02,0x40,0x02,0xC0,0x02,0x40,0x02,0xC0,0x02,0x40,0x02,0xC0,
 0x02,0x40,0x03,0xC0,0x07,0xE0,0x0F,0xF0,0x0F,0xF0,0x07,0xE0,0x03,0xC0,0x00,0x00}
};
/*12864液晶显示屏并口驱动程序--------------------------------------------------------*/
//检查忙位
void chk_busy()
{
   LCM_RS=0; LCM_RW=1; LCM_EN=1;
   Lcd_Bus=0xff;
   while((Lcd_Bus&0x80)==0x80);
   LCM_EN=0;
}
/*写指令到LCD------------------------------------------------------------------------*/
void write_com(uchar cmdcode)
{
	chk_busy();
	LCM_RS=0; LCM_RW=0; LCM_EN=1;
	Lcd_Bus=cmdcode;
	LCM_EN=0;
}
/*写数据到LCD------------------------------------------------------------------------*/
void write_data(uchar Dispdata)
{	 
	chk_busy();
	LCM_RS=1; LCM_RW=0; LCM_EN=1;
	Lcd_Bus=Dispdata;
	LCM_EN=0;
}
/*向LCM发送一个字符串,长度64字符之内-------------------------------------------------*/
void lcm_w_word(uchar *s)
{
	while(*s>0) { write_data(*s); s++; }  //应用：lcm_w_word("您好！");
}
/******************************************************************************/
void lcm_w_test(bit i,unsigned char word){//写指令或数据（被调用层）
	if(i == 0){
		write_com(word);//写指令（0，指令）
	}else{
		write_data(word);//写数据（1，数据）
	}
}
/*清屏函数--------------------------------------------------------------------------*/
void lcm_clr(void)
{
	write_com(0x01);	
}

/******************************************************************************/

void lcm_clr2(void){//清屏上面3行（用空格填满要清显示的地方，因为液晶屏是静态显示的，所以这办法常用）
	lcm_w_test(0,0x80);//第一行
	lcm_w_word("                ");
	    //标尺("1234567812345678"应该能够显示满一行)
   lcm_w_test(0,0x90);//第二行
	lcm_w_word("                ");
	    //标尺("1234567812345678"应该能够显示满一行)
   lcm_w_test(0,0x88);//第一行
	lcm_w_word("                ");
	    //标尺("1234567812345678"应该能够显示满一行)
}

/*初始化LCD屏------------------------------------------------------------------------*/
void lcm_init()
{  
	write_com(0x30);  //选择8bit数据流
	write_com(0x0c);  //开显示(无游标、不反白)
	lcm_clr();        //清除显示，并且设定地址指针为00H
	write_com(0x06);  //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
lcm_clr2();
}
/*使用绘图的方法让一个16*16的汉字符反白----------------------------------------------*/
//形式参数:uchar x,uchar y,uchar wide,uchar bkcor
//行参说明:坐标水平位置,坐标垂直位置,反白行数,要反白还是清除(1:反白,0:清除)   
void write1616GDRAM(uchar x,uchar y,uchar sign,uchar *bmp)	
{ 
	uchar i,j,basex;
	write_com(0x36);      //扩展指令，绘图模式命令，开显示也可以绘.(关图片显示0x34)
	if(y==1||y==2)	  //第一第二行
	{
		basex=0x80;	   //上半屏
		y=(y-1)*16;	  //垂直位址从0X80开始.
	}
	if(y==3||y==4)	//第三第四行
	{
		basex=0x88;	 //下半屏
		y=(y-3)*16;	 //垂直位址都是从0X80开始的，不管上下半屏。
	}
	for(i=0;i<16;i++)	//
	{															
		write_com(0x80+y+i);  //写入垂直位址。
		write_com(basex+x-1); //再写入水平位址(上半屏第一字为0X80，……第七字为0X87)
							   //下半屏第一字为0X88，……第七字为0X8F；
		for(j=0;j<2;j++)   //再写入两个8位元的数据,AC会自动增一，接着写数据
		{
			if(sign==1)  
				write_data(~(*bmp++));
			else  
				write_data(*bmp++);
		}
	}	
	write_com(0x36);  //写完数据，开图片显示     
}

/**************************************************************************************
//函数功能:显示16X16图形,适用于st7920型液晶
//形式参数:uchar x,uchar y,uchar *bmp
//行参说明:横坐标X列，纵坐标Y行，sign=1反白、=0不反，tt是要显示的图形bmp1616中的第几个
//************************************************************************************/ 
void set1616pic(uchar x,uchar y,uchar sign,uchar tt) 
{
	uchar (*pp)[32];	 //定义指针
	pp=bmp1616;	  //二维数组首地址给指针，故指针指向下一个数组地址应为加64
	write1616GDRAM(x,y,sign,pp[tt]); //写入小时的十位	  
}
/**************************************************************************************
//函数功能:显示16X32图形,适用于st7920型液晶
//形式参数:uchar x,uchar y,uchar *bmp
//行参说明:横坐标X列，纵坐标Y行，要显示的图形BMP
//************************************************************************************/           
void write1632GDRAM(uchar x,uchar y,uchar *bmp)	
{ 
	uchar i,j,basex,basey;
	switch(y)	 //由y纵坐标定是上半屏还是下半屏
	{
	  case 1: basex=0x80; break;  //上半屏
	  case 2: basex=0x80; break;  //先上半屏，下面再下半屏。
	  case 3: basex=0x88; break;  //下半屏
	  default:   return;   //别的则返回
	}
	basey=basex+x-1;
	write_com(0x36);  
	if(y==1||y==3)	//如为第一第三行，则直接是在同一半屏，直接绘完32行点陈数据。
	{
		  for(i=0;i<32;i++)	 //写入32行点阵
		  {														
			    write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
			    write_com(basey);     //再写入水平位址(选上下半屏)
			    for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
			    	write_data(*bmp++);   
		  }	 
	}
	if(y==2)  //从第二行开始则画图将上下半屏都有，所以先画完上半屏16行，再画下半屏16行。
	{					
		  for(i=0;i<16;i++)	 //写入上半屏16行点阵
		  {														
			    write_com(0x90+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80，第二行为0X90。
			    write_com(basey);    //(选上半屏)再写入水平位址
			    for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
			    	write_data(*bmp++);   
		  }
		  for(i=0;i<16;i++)	 //写入下半屏16行点阵
		  {														
			    write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
			    write_com(basey+8);   //(选下半屏)再写入水平位址
			    for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
			    	write_data(*bmp++);   
		  }	 
	}
	write_com(0x36);  //写完数据，开图片显示     
}
/**************************************************************************************        
** 函数名称: init_12864_GDRAM()
** 功能描述: 在程写GDRAM时序初始化12864 
**************************************************************************************/
void init_12864_GDRAM()	 
{
	write_com(0x30);     //基本指令操作(扩充指令操作为:0x34)
	write_com(0x0C);     //整体显示ON，游标OFF，游标位置OFF
	write_com(0x06);  	 //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
	lcm_clr();           //清屏 (清DDRAM)
}

/**************************************************************************************
//函数名称:Clean_12864_GDRAM(void)						
//函数功能:清屏函数
//使用说明:GDRAM填满0
//************************************************************************************/
void Clean_12864_GDRAM(void)
{
    uchar x,y;
    write_com(0x36);
    init_12864_GDRAM();		//设置扩展指令集，按手册说明，仅设置了绘图位，
    write_com(0x36);	//需要两次，本次设置扩展指令集。
    for (y=0;y<32;y++)
    {
        write_com(0x80+y);  //设置y=1000+00xx，y+1则往下一行
        write_com(0x80);	//设置x=1000 0000
        for (x=0;x<16;x++)
        {
            write_data(0x00);   //高字节数据
            write_data(0x00);	//低字节数据
        }
    }
}
/*-----------------------------------------------------------------------------------*/ 
#endif 